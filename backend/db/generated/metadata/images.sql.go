// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: images.sql

package metadata

import (
	"context"
	"database/sql"
)

const deleteImageByID = `-- name: DeleteImageByID :exec
DELETE FROM images
WHERE id = ?
`

func (q *Queries) DeleteImageByID(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteImageByID, id)
	return err
}

const insertImage = `-- name: InsertImage :exec

INSERT INTO images (
    id, filename, mime_type_id, thumbnail, hash, created_at, edited_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
`

type InsertImageParams struct {
	ID         string
	Filename   string
	MimeTypeID int64
	Thumbnail  []byte
	Hash       string
	CreatedAt  sql.NullTime
	EditedAt   sql.NullTime
}

// IMAGES --
func (q *Queries) InsertImage(ctx context.Context, arg InsertImageParams) error {
	_, err := q.db.ExecContext(ctx, insertImage,
		arg.ID,
		arg.Filename,
		arg.MimeTypeID,
		arg.Thumbnail,
		arg.Hash,
		arg.CreatedAt,
		arg.EditedAt,
	)
	return err
}

const selectAllImagesWithMime = `-- name: SelectAllImagesWithMime :many
SELECT
    i.id,
    i.filename,
    i.mime_type_id,
    m.mime,
    i.thumbnail,
    i.hash,
    i.created_at,
    i.edited_at
FROM images i
JOIN mime_types m ON i.mime_type_id = m.id
ORDER BY i.created_at DESC
`

type SelectAllImagesWithMimeRow struct {
	ID         string
	Filename   string
	MimeTypeID int64
	Mime       string
	Thumbnail  []byte
	Hash       string
	CreatedAt  sql.NullTime
	EditedAt   sql.NullTime
}

func (q *Queries) SelectAllImagesWithMime(ctx context.Context) ([]SelectAllImagesWithMimeRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllImagesWithMime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllImagesWithMimeRow
	for rows.Next() {
		var i SelectAllImagesWithMimeRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.MimeTypeID,
			&i.Mime,
			&i.Thumbnail,
			&i.Hash,
			&i.CreatedAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectImageByHash = `-- name: SelectImageByHash :one
SELECT
    id, filename, mime_type_id, thumbnail, hash, created_at, edited_at
FROM images
WHERE hash = ?
`

func (q *Queries) SelectImageByHash(ctx context.Context, hash string) (Image, error) {
	row := q.db.QueryRowContext(ctx, selectImageByHash, hash)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.MimeTypeID,
		&i.Thumbnail,
		&i.Hash,
		&i.CreatedAt,
		&i.EditedAt,
	)
	return i, err
}

const selectImageByID = `-- name: SelectImageByID :one
SELECT
    id, filename, mime_type_id, thumbnail, hash, created_at, edited_at
FROM images
WHERE id = ?
`

func (q *Queries) SelectImageByID(ctx context.Context, id string) (Image, error) {
	row := q.db.QueryRowContext(ctx, selectImageByID, id)
	var i Image
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.MimeTypeID,
		&i.Thumbnail,
		&i.Hash,
		&i.CreatedAt,
		&i.EditedAt,
	)
	return i, err
}

const selectImagesByDateRange = `-- name: SelectImagesByDateRange :many
SELECT
    i.id,
    i.filename,
    i.mime_type_id,
    m.mime,
    i.thumbnail,
    i.hash,
    i.created_at,
    i.edited_at
FROM images i
JOIN mime_types m ON i.mime_type_id = m.id
WHERE i.created_at BETWEEN ? AND ?
ORDER BY i.created_at DESC
`

type SelectImagesByDateRangeParams struct {
	FromCreatedAt sql.NullTime
	ToCreatedAt   sql.NullTime
}

type SelectImagesByDateRangeRow struct {
	ID         string
	Filename   string
	MimeTypeID int64
	Mime       string
	Thumbnail  []byte
	Hash       string
	CreatedAt  sql.NullTime
	EditedAt   sql.NullTime
}

func (q *Queries) SelectImagesByDateRange(ctx context.Context, arg SelectImagesByDateRangeParams) ([]SelectImagesByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, selectImagesByDateRange, arg.FromCreatedAt, arg.ToCreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectImagesByDateRangeRow
	for rows.Next() {
		var i SelectImagesByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.MimeTypeID,
			&i.Mime,
			&i.Thumbnail,
			&i.Hash,
			&i.CreatedAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectImagesByMimeTypeID = `-- name: SelectImagesByMimeTypeID :many
SELECT
    i.id,
    i.filename,
    i.mime_type_id,
    m.mime,
    i.thumbnail,
    i.hash,
    i.created_at,
    i.edited_at
FROM images i
JOIN mime_types m ON i.mime_type_id = m.id
WHERE i.mime_type_id = ?
ORDER BY i.created_at DESC
`

type SelectImagesByMimeTypeIDRow struct {
	ID         string
	Filename   string
	MimeTypeID int64
	Mime       string
	Thumbnail  []byte
	Hash       string
	CreatedAt  sql.NullTime
	EditedAt   sql.NullTime
}

func (q *Queries) SelectImagesByMimeTypeID(ctx context.Context, mimeTypeID int64) ([]SelectImagesByMimeTypeIDRow, error) {
	rows, err := q.db.QueryContext(ctx, selectImagesByMimeTypeID, mimeTypeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectImagesByMimeTypeIDRow
	for rows.Next() {
		var i SelectImagesByMimeTypeIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.MimeTypeID,
			&i.Mime,
			&i.Thumbnail,
			&i.Hash,
			&i.CreatedAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMimeTypeByImageID = `-- name: SelectMimeTypeByImageID :one
SELECT m.mime
FROM images i
JOIN mime_types m ON i.mime_type_id = m.id
WHERE i.id = ?
`

func (q *Queries) SelectMimeTypeByImageID(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, selectMimeTypeByImageID, id)
	var mime string
	err := row.Scan(&mime)
	return mime, err
}

const selectThumbnailAndMimeByID = `-- name: SelectThumbnailAndMimeByID :one
SELECT i.thumbnail, m.mime
FROM images i
JOIN mime_types m ON i.mime_type_id = m.id
WHERE i.id = ?
`

type SelectThumbnailAndMimeByIDRow struct {
	Thumbnail []byte
	Mime      string
}

func (q *Queries) SelectThumbnailAndMimeByID(ctx context.Context, id string) (SelectThumbnailAndMimeByIDRow, error) {
	row := q.db.QueryRowContext(ctx, selectThumbnailAndMimeByID, id)
	var i SelectThumbnailAndMimeByIDRow
	err := row.Scan(&i.Thumbnail, &i.Mime)
	return i, err
}

const selectThumbnailByID = `-- name: SelectThumbnailByID :one
SELECT thumbnail
FROM images
WHERE id = ?
`

func (q *Queries) SelectThumbnailByID(ctx context.Context, id string) ([]byte, error) {
	row := q.db.QueryRowContext(ctx, selectThumbnailByID, id)
	var thumbnail []byte
	err := row.Scan(&thumbnail)
	return thumbnail, err
}

const updateImageMetadataByID = `-- name: UpdateImageMetadataByID :exec
UPDATE images
SET filename = ?, mime_type_id = ?, edited_at = ?
WHERE id = ?
`

type UpdateImageMetadataByIDParams struct {
	Filename   string
	MimeTypeID int64
	EditedAt   sql.NullTime
	ID         string
}

func (q *Queries) UpdateImageMetadataByID(ctx context.Context, arg UpdateImageMetadataByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateImageMetadataByID,
		arg.Filename,
		arg.MimeTypeID,
		arg.EditedAt,
		arg.ID,
	)
	return err
}
